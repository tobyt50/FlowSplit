// ------------------------------------------------------
// FlowSplit Prisma Schema
// ------------------------------------------------------
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
  BUSINESS
}

enum TransactionType {
  CREDIT
  DEBIT
  TRANSFER
}

enum SplitType {
  PERCENTAGE
  FIXED
}

enum Provider {
  PAYSTACK
  FLUTTERWAVE
  PLAID
  MANUAL
}

enum WalletType {
  PERSONAL
  SAVINGS
  BILL
  INVESTMENT
  SOURCE
}

enum PayoutStatus {
  PENDING
  PROCESSING
  SUCCESS
  FAILED
}

enum AccountType {
  SAVINGS
  CURRENT
}

enum LedgerEntryType {
  DEBIT
  CREDIT
}

enum Currency {
  NGN
}

// --------------------- MODELS ---------------------------

model User {
  id        String   @id @default(cuid())
  fullName  String
  email     String   @unique
  password  String?
  avatarUrl String?
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  accounts      Account[]
  wallets       Wallet[]
  splitRules    SplitRule[]
  transactions  Transaction[]
  notifications Notification[]
  analytics     Analytics?

  provider   Provider?
  providerId String?   @unique

  bankAccounts BankAccount[]
  payouts      Payout[]
}

model LedgerTransaction {
  id          String        @id
  description String
  createdAt   DateTime      @default(now())

  // Relation: A transaction consists of multiple debit/credit entries.
  entries     LedgerEntry[]
}

// Represents a single debit or credit to a specific wallet.
model LedgerEntry {
  id                  String          @id
  amount              BigInt          // The amount in kobo, always positive.
  type                LedgerEntryType // DEBIT or CREDIT
  createdAt           DateTime        @default(now())

  walletId            String
  wallet              Wallet          @relation(fields: [walletId], references: [id])

  ledgerTransactionId String
  ledgerTransaction   LedgerTransaction @relation(fields: [ledgerTransactionId], references: [id])

  @@unique([ledgerTransactionId, walletId, type])
}

model Wallet {
  id        String     @id @default(cuid())
  name      String
  type      WalletType @default(PERSONAL)
  balance   BigInt      @default(0)
  currency  Currency   @default(NGN)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  transactions        Transaction[] @relation("WalletTransactions")
  destinationForRules SplitRule[]
  ledgerEntries       LedgerEntry[]
  payoutsFrom Payout[]
}

model Account {
  id            String   @id @default(cuid())
  bankName      String
  accountNumber String
  balance       BigInt    @default(0)
  provider      Provider @default(MANUAL)
  isPrimary     Boolean  @default(false)
  linkedAt      DateTime @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id])

  transactions Transaction[]
}

model BankAccount {
  id              String      @id
  userId          String
  user            User        @relation(fields: [userId], references: [id])
  bankName        String
  bankCode        String      
  accountNumber   String
  accountName     String      
  accountType     AccountType @default(SAVINGS)
  isPrimary       Boolean     @default(false)
  isVerified      Boolean     @default(false)
  provider        Provider    // e.g., PAYSTACK
  providerRef     String?     
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  payouts         Payout[]

  @@unique([userId, accountNumber, bankCode])
}

model Payout {
  id                String       @id
  userId            String
  user              User         @relation(fields: [userId], references: [id])
  sourceWalletId    String
  sourceWallet      Wallet       @relation(fields: [sourceWalletId], references: [id])
  destinationBankId String
  destinationBank   BankAccount  @relation(fields: [destinationBankId], references: [id])
  amount            BigInt       // Amount in kobo
  currency          Currency
  reference         String       @unique
  providerReference String?      
  status            PayoutStatus @default(PENDING)
  failureReason     String?
  initiatedAt       DateTime     @default(now())
  completedAt       DateTime?

  ledgerTransactionId String?    @unique
}

model SplitRule {
  id                  String    @id @default(cuid())
  name                String
  type                SplitType @default(PERCENTAGE)
  value               Float
  destinationWalletId String?
  destinationWallet   Wallet?   @relation(fields: [destinationWalletId], references: [id])
  priority            Int       @default(1)
  isActive            Boolean   @default(true)
  createdAt           DateTime  @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id])
}

model Transaction {
  id           String          @id @default(cuid())
  reference    String          @unique
  type         TransactionType
  amount       BigInt
  currency      Currency        @default(NGN)
  category     String?
  description  String?
  status       String          @default("SUCCESS")
  initiatedAt  DateTime        @default(now())
  completedAt  DateTime?
  splitApplied Boolean         @default(false)

  userId String
  user   User   @relation(fields: [userId], references: [id])

  accountId String?
  account   Account? @relation(fields: [accountId], references: [id])

  walletId String?
  wallet   Wallet? @relation("WalletTransactions", fields: [walletId], references: [id])
}

model Analytics {
  id           String   @id @default(cuid())
  totalInflow  BigInt    @default(0)
  totalOutflow BigInt    @default(0)
  totalSavings BigInt    @default(0)
  updatedAt    DateTime @updatedAt

  userId String @unique
  user   User   @relation(fields: [userId], references: [id])
}

model Notification {
  id        String   @id @default(cuid())
  title     String
  message   String
  type      String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id])
}

model WebhookEvent {
  id         String   @id @default(cuid())
  eventType  String
  payload    Json
  receivedAt DateTime @default(now())
  processed  Boolean  @default(false)
}
